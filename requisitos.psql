-- REQUISTO 1

-- função usada para a criação de chips, recebe o id da operadora e o id do 
-- seu estado ao qual se deseja gerar chips, não insere:
-- 1) números repetidos
-- 2) números terminados em 0000
-- por padrão quando o chip é criado ele é inativo e disponível, seu plano
-- é o plano de id 1 que pode ser usado por todas as operadoas

CREATE OR REPLACE FUNCTION gerar_numero(operadora INT, estado VARCHAR(2))
RETURNS VARCHAR
AS $$
	DECLARE 
		ddd VARCHAR(2);
		prefixo VARCHAR(4);
		complemento VARCHAR(4);
		numero VARCHAR(11);
		loopComplemento BOOLEAN = true;
		loopChip BOOLEAN = true;
		idpl INT;
		verificao VARCHAR(11);
	BEGIN
		-- Definicao do ddd
		SELECT es.ddd INTO ddd FROM estado es WHERE es.uf = estado;
		IF ddd IS null THEN		
			RETURN 'Estado nao encontrado.';
		END IF;
		
		-- loop de tentativas para gerar o chip
		WHILE loopChip = true
		LOOP
			-- Definicao do prefixo 985 + (1 ou 2)
			prefixo := '985' || (CAST ((FLOOR(random()*(2-1+1))+1) AS VARCHAR));

			-- Formacao do corpo do numero
			complemento := (CAST ((FLOOR(random()*(9-1+1))+1) AS VARCHAR));

			WHILE loopComplemento = true
			LOOP
				complemento := (CAST ((FLOOR(random()*(9-1+1))+1) AS VARCHAR));
				FOR i IN 1..3 BY 1
				LOOP
					complemento := complemento || (CAST ((FLOOR(random()*(9-1+1))+1) AS VARCHAR));
				END LOOP; -- for

				IF complemento != '0000' THEN
					loopComplemento := FALSE;
				END IF;

			END LOOP;
			
			-- numero completo
			numero := ddd || prefixo || complemento;
			
			-- verificacao se o numero existe no banco
			SELECT idnumero INTO verificao FROM chip WHERE idnumero = numero;
			IF verificao is null THEN
				loopChip := false;
			END IF;
		END LOOP;

		-- escolha de um plano aleatorio
		SELECT idplano INTO idpl FROM plano ORDER BY random() LIMIT 1
		
		-- adicao do chip no banco
		INSERT INTO chip(idnumero, idoperadora, idplano, ativo, disponivel)
		VALUES (numero, operadora, idpl, 'N', 'S');
		
		RETURN 
		'Chip criado para a operadora ' 
		|| (select nome from operadora op where op.idoperadora = operadora) 
		|| ': ' || numero;
	END
$$
LANGUAGE 'plpgsql';



-- REQUISITO 2
-- função usada para retornar até 5 chips disponiveis ao cliente
CREATE OR REPLACE FUNCTION numeros_disponiveis()
RETURNS TABLE (numero CHAR(11))
AS $$
	BEGIN
		RETURN QUERY SELECT idnumero FROM chip WHERE disponivel = 'S' LIMIT 5;
	END
$$
LANGUAGE 'plpgsql';



-- REQUISITO 3

-- FUNÇAO DE SUPORTE: recebe uma data e retorna a data do ultimo dia de um mes.
CREATE OR REPLACE FUNCTION ultimo_dia(date)
RETURNS date AS
$$
  SELECT (date_trunc('MONTH', $1) + INTERVAL '1 MONTH - 1 day')::date;
$$ LANGUAGE 'sql' IMMUTABLE STRICT;


-- FUNÇÃO DE SUPORTE: recebe dois chips e retorna true caso os dois pertencam
-- a mesma operadora e false caso contrario ou em caso de erro
CREATE OR REPLACE FUNCTION mesma_operadora(chip_1 VARCHAR(11), chip_2 VARCHAR(11))
RETURNS BOOLEAN
AS $$
DECLARE
	operadora_1 INT;
	operadora_2 INT;
BEGIN
	-- operadora do primeiro chip
	SELECT idoperadora INTO operadora_1
	FROM CHIP WHERE idnumero = chip_1;

	-- operadora do segundo chip
	SELECT idoperadora INTO operadora_2
	FROM CHIP WHERE idnumero = chip_2;
	
	IF operadora_1 = operadora_2 THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END $$ 
LANGUAGE plpgsql;



-- FUNCAO DE SUPORTE: retorna um numero inteiro para cada minuto
-- de uma variavel time
CREATE OR REPLACE FUNCTION int_ToMin(inteiro INT)
RETURNS TIME
AS $$
DECLARE
	minutos TIME = '00:00:00';
BEGIN
	FOR i IN 1..inteiro BY 1
	LOOP
		minutos := minutos + '00:01:00';
	END LOOP;
	RETURN minutos;
END $$ 
LANGUAGE plpgsql;



-- FUNCAO DE SUPORTE: recebe uma taxa e uma duracao em formato de tempo
-- retorna o custo dessa duracao multiplicado pela taxa
CREATE OR REPLACE FUNCTION minTo_Val(taxaPorMin NUMERIC, duracao TIME)
RETURNS NUMERIC
AS $$
DECLARE
	contador INT = 0;
	horas INT;
	minutos INT;
	segundos INT;
BEGIN
	SELECT INTO segundos CAST((EXTRACT (SECOND FROM duracao)) AS INT);
	SELECT INTO minutos CAST((EXTRACT (MINUTE FROM duracao)) AS INT);
	SELECT INTO horas CAST((EXTRACT (HOUR FROM duracao)) AS INT);
	
	-- de segundos para o contador
	IF segundos >= 30 THEN 
		contador := contador + 1;
	END IF;
	-- minutos para o contador
	contador := contador + minutos;
	
	-- de horas para o contador
	contador := contador + (horas * 60);
	RETURN contador * taxaPorMin;
END $$ 
LANGUAGE plpgsql;

-- FUNCAO DE SUPORTE: retorna um record com os dados do plano
-- de um numero 
CREATE OR REPLACE FUNCTION get_plano(numero VARCHAR(11))
RETURNS RECORD
AS $$
DECLARE
	plano RECORD;
BEGIN
	SELECT pla.fminin, pla.fminout, pla.valor, ch1.idnumero 
	INTO plano FROM plano pla INNER JOIN chip ch1 ON ch1.idplano = pla.idplano	
	WHERE pla.idplano = (
		SELECT idplano FROM chip ch
		WHERE ch.idnumero = numero
		LIMIT 1
	);
	RETURN plano;
END $$ 
LANGUAGE plpgsql;


-- PROCEDURE QUE GERA FATURAS
CREATE OR REPLACE PROCEDURE gerar_faturas(ano INT, mes INT)
LANGUAGE plpgsql
AS $$
DECLARE
	-- variaveis de controle
	chip RECORD;
	ligacao RECORD;
	datafatura DATE;
	datafinal DATE;
	existe CHAR(1);
	pl plano%ROWTYPE;
	
	-- variaveis exclusivas da fatura
	minIn INT;
	minOut INT;
	exced NUMERIC(5,2);
	roaming NUMERIC(5,2);
	total NUMERIC(7,2);
	
BEGIN
	-- definicao da data da fatura
	datafatura = ano || '-' || mes || '-01';
	
	-- definicao da data do ultimo dia do mes da fatura
	SELECT ultimo_dia(datafatura) INTO datafinal;
	
	-- seleciona todos os chips ativos em uma tabela
	FOR chip IN SELECT * FROM chip WHERE ativo = 'S'
	LOOP
		-- verificacao se ja existe fatura para esse chip nessa data
		SELECT pago INTO existe 
		FROM fatura WHERE referencia = datafatura 
		AND idnumero = chip.idnumero;
		
		IF existe IS NULL THEN
			-- busca pelo plano do chip
			SELECT * INTO pl FROM plano WHERE idplano = (
				SELECT idplano FROM chip 
				WHERE idnumero = chip.idnumero
				LIMIT 1
			)
			
			-- adicao dos dados do plano nas variaveis da fatura
			minIn := pl.fminin
			minOut := pl.fminout
			total := pl.valor
			
			-- busca por todas as ligacoes do chip feitas no periodo
			-- da fatura
			FOR ligacao IN SELECT * FROM ligacao li
			WHERE li.chip_emissor = chip.idnumero 
			AND (li.data >= datafatura AND li.data <= datafinal)
			LOOP
				-- verificacao se a ligacao foi feita para a mesma operadora
				
							
			
			END LOOP
		END IF;
	END LOOP;
END $$;

select * from plano



-- REQUSITO 5

CREATE OR REPLACE PROCEDURE PR_ASSOC_NUMERO_CLIENTE(ID_CLIENTE INTEGER, DDD VARCHAR, PREFIXO VARCHAR)
LANGUAGE PLPGSQL
AS $$
DECLARE
	IS_CANCELADO VARCHAR;
	NUMERO VARCHAR;
	OPERADORA_CLIENTE INTEGER;
	PLANO_CLIENTE INTEGER;
BEGIN
	SELECT CLIENTE.CANCELADO INTO IS_CANCELADO FROM CLIENTE WHERE CLIENTE.IDCLIENTE = ID_CLIENTE;
	IF IS_CANCELADO = 'N' THEN
		-- GERANDO O NUMERO TELEFONICO E PEGANDO UM PLANO,OPERADORA PARA SER INSERIDO
		SELECT FN_GERA_NUMERO_TELEFONE(DDD, PREFIXO) INTO NUMERO;
		SELECT * INTO PLANO_CLIENTE FROM (SELECT IDPLANO FROM PLANO ORDER BY RANDOM() LIMIT 1) AS "PLANO";
		SELECT * INTO OPERADORA_CLIENTE FROM(SELECT IDOPERADORA FROM OPERADORA ORDER BY RANDOM() LIMIT 1) AS "OPERADORA_CLIENTE";
		--INSERINDO NA TABELA CHIP
		INSERT INTO CHIP(IDNUMERO, IDOPERADORA, DISPONIVEL, IDPLANO, ATIVO)
		VALUES(NUMERO, OPERADORA_CLIENTE, PLANO_CLIENTE, 'N','S');
		COMMIT;
		--INSERINDO NA TABELA CLIENTE_CHIP
		INSERT INTO CLIENTE_CHIP(IDNUMERO, IDCLIENTE)
		VALUES(NUMERO,IDCLIENTE);
		COMMIT;
	ELSE
		RAISE EXCEPTION 'O CLIENTE APRESENTA O STATUS CANCELADO';
	END IF;
END $$;


--VIEW 1
CREATE OR REPLACE VIEW VW_1
AS SELECT PLANO.IDPLANO, PLANO.DESCRICAO, COUNT(CHIP.IDPLANO) AS QUANT_PLANOS_ATIVOS,(COUNT(CHIP.*)*PLANO.VALOR) AS VALOR_ARRECADADO
FROM PLANO JOIN CHIP
ON PLANO.IDPLANO = CHIP.IDPLANO
GROUP BY PLANO.IDPLANO, CHIP.ATIVO, CHIP.IDPLANO
HAVING CHIP.ATIVO = 'S';


--VIEW 3
CREATE OR REPLACE VIEW VW_3
AS
SELECT CLIENTE.IDCLIENTE, CLIENTE.NOME, ESTADO.UF, CHIP.IDNUMERO,PLANO.DESCRICAO, TO_CHAR(current_date - datacadastro, 'MM/YYYY') AS Tempo_na_empresa
FROM CLIENTE JOIN CIDADE
ON CLIENTE.IDCIDADE = CIDADE.IDCIDADE
JOIN ESTADO
ON ESTADO.UF = CIDADE.UF
JOIN CLIENTE_CHIP
ON CLIENTE.IDCLIENTE = CLIENTE_CHIP.IDCLIENTE
JOIN CHIP
ON CHIP.IDNUMERO = CLIENTE_CHIP.IDNUMERO
JOIN PLANO
ON CHIP.IDPLANO = PLANO.IDPLANO
WHERE CLIENTE.CANCELADO = 'N'
